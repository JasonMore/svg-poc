// Generated by CoffeeScript 1.6.3
var EventEmitter, Readable, arraydiff, assert, deepEquals, isError, ot, rateLimit, redisLib,
  __slice = [].slice;

Readable = require('stream').Readable;

EventEmitter = require('events').EventEmitter;

assert = require('assert');

isError = require('util').isError;

deepEquals = require('deep-is');

redisLib = require('redis');

arraydiff = require('arraydiff');

ot = require('./ot');

rateLimit = require('./ratelimit');

exports.memory = require('./memory');

exports.client = function(options) {
  var atomicSubmit, client, extraDbs, getDocOpChannel, getOpLogKey, getOps, getVersionKey, logEntryForData, nextStreamId, oplog, oplogGetOps, prefixChannel, processRedisOps, redis, redisGetOps, redisObserver, redisSetExpire, redisSubmitScript, snapshotDb, streams, subscribeCounts, writeOpToLog;
  snapshotDb = options.snapshotDb || options.db || options;
  if (!(snapshotDb.getSnapshot && snapshotDb.writeSnapshot)) {
    throw new Error('Missing or invalid snapshot db');
  }
  oplog = options.oplog || options.db || options;
  if (!(oplog.writeOp && oplog.getVersion && oplog.getOps)) {
    throw new Error('Missing or invalid operation log');
  }
  redis = options.redis || redisLib.createClient();
  redisObserver = options.redisObserver;
  if (!redisObserver) {
    redisObserver = redisLib.createClient(redis.port, redis.host, redis.options);
    if (redis.auth_pass) {
      redisObserver.auth(redis.auth_pass);
    }
  }
  redisObserver.setMaxListeners(0);
  extraDbs = options.extraDbs || {};
  streams = {};
  nextStreamId = 0;
  subscribeCounts = {};
  prefixChannel = function(channel) {
    return "" + (redis.selected_db || 0) + " " + channel;
  };
  getVersionKey = function(cName, docName) {
    return "" + cName + "." + docName + " v";
  };
  getOpLogKey = function(cName, docName) {
    return "" + cName + "." + docName + " ops";
  };
  getDocOpChannel = function(cName, docName) {
    return "" + cName + "." + docName;
  };
  processRedisOps = function(to, result) {
    var docV, op, v, value, _i, _len, _results;
    docV = result.pop();
    v = to === -1 ? docV - result.length : to - result.length + 1;
    _results = [];
    for (_i = 0, _len = result.length; _i < _len; _i++) {
      value = result[_i];
      op = JSON.parse(value);
      op.v = v++;
      _results.push(op);
    }
    return _results;
  };
  logEntryForData = function(opData) {
    var entry;
    entry = {};
    if (opData.src) {
      entry.src = opData.src;
    }
    if (opData.seq) {
      entry.seq = opData.seq;
    }
    if (opData.op) {
      entry.op = opData.op;
    } else if (opData.del) {
      entry.del = opData.del;
    } else if (opData.create) {
      entry.create = opData.create;
    }
    return entry;
  };
  redisSubmitScript = function(cName, docName, opData, docVersion, callback) {
    var docPubEntry, logEntry;
    logEntry = JSON.stringify(logEntryForData(opData));
    docPubEntry = JSON.stringify(opData);
    return redis["eval"]("local clientNonceKey, versionKey, opLogKey, docOpChannel = unpack(KEYS)\nlocal seq, v, logEntry, docPubEntry, docVersion = unpack(ARGV) -- From redisSubmit, below.\nv = tonumber(v)\nseq = tonumber(seq)\ndocVersion = tonumber(docVersion)\n\n-- Check the version matches.\nif docVersion ~= nil then\n  -- setnx returns true if we set the value.\n  if redis.call('setnx', versionKey, docVersion) == 0 then\n    docVersion = tonumber(redis.call('get', versionKey))\n  else\n    -- We've just set the version ourselves. Wipe any junk in the oplog.\n    redis.call('del', opLogKey)\n  end\nelse\n  docVersion = tonumber(redis.call('get', versionKey))\nend\n\nif docVersion == nil then\n  -- This is not an error - it will happen whenever the TTL expires or redis is wiped.\n  return \"Missing data\"\nend\n\n\nif v < docVersion then\n  -- The operation needs transformation. I could short-circuit here for\n  -- performance and return any ops in redis, but livedb logic is simpler if I\n  -- simply punt to getOps() below, and I don't think its a bottleneck.\n  return \"Transform needed\"\n  --local ops = redis.call('lrange', opLogKey, -(docVersion - v), -1) \n  --ops[#ops + 1] = docVersion\n  --return ops\nelseif v > docVersion then\n  -- Redis's version is older than the snapshot database. We might just be out\n  -- of date, though it should be mostly impossible to get into this state.\n  -- We'll dump all our data and expect to be refilled from whatever is in the\n  -- persistant oplog.\n  redis.call('del', versionKey)\n  return \"Version from the future\"\nend\n\n-- Dedup, but only if the id has been set.\nif seq ~= nil then\n  local nonce = redis.call('GET', clientNonceKey)\n  if nonce ~= false and tonumber(nonce) >= seq then\n    return \"Op already submitted\"\n  end\nend\n\n-- Ok to submit. Save the op in the oplog and publish.\nredis.call('rpush', opLogKey, logEntry)\nredis.call('set', versionKey, v + 1)\n\nredis.call('persist', opLogKey)\nredis.call('persist', versionKey)\n\nredis.call('publish', docOpChannel, docPubEntry)\n\n-- Finally, save the new nonce. We do this here so we only update the nonce if\n-- we're at the most recent version in the oplog.\nif seq ~= nil then\n  --redis.log(redis.LOG_NOTICE, \"set \" .. clientNonceKey .. \" to \" .. seq)\n  redis.call('SET', clientNonceKey, seq)\n  redis.call('EXPIRE', clientNonceKey, 60*60*24*7) -- 1 week\nend", 4, opData.src, getVersionKey(cName, docName), getOpLogKey(cName, docName), prefixChannel(getDocOpChannel(cName, docName)), opData.seq, opData.v, logEntry, docPubEntry, docVersion, function(err, result) {
      if (err) {
        return callback(err);
      }
      return callback(err, result);
    });
  };
  atomicSubmit = function(cName, docName, opData, callback) {
    return redisSubmitScript(cName, docName, opData, null, function(err, result) {
      if (err) {
        return callback(err);
      }
      if (result === 'Missing data' || result === 'Version from the future') {
        return oplog.getVersion(cName, docName, function(err, version) {
          if (err) {
            return callback(err);
          }
          if (version > 0) {
            console.warn("Repopulating redis for " + cName + "." + docName + " " + opData.v + version, result);
          }
          if (version < opData.v) {
            throw new Error("Missing oplog for " + cName + " " + docName);
          }
          return redisSubmitScript(cName, docName, opData, version, callback);
        });
      } else {
        return callback(null, result);
      }
    });
  };
  redisGetOps = function(cName, docName, from, to, callback) {
    if (to == null) {
      to = -1;
    }
    if (to >= 0) {
      if (from >= to || to === 0) {
        return callback(null, []);
      }
      to--;
    }
    return redis["eval"]("local versionKey, opLogKey = unpack(KEYS)\nlocal from = tonumber(ARGV[1])\nlocal to = tonumber(ARGV[2])\n\nlocal v = tonumber(redis.call('get', versionKey))\n\n-- We're asking for ops the server doesn't have.\nif v == nil or from >= v then return nil end\n\n--redis.log(redis.LOG_NOTICE, \"v \" .. tostring(v) .. \" from \" .. from .. \" to \" .. to)\nif to >= 0 then\n  to = to - v\nend\nfrom = from - v\n\nlocal ops = redis.call('lrange', opLogKey, from, to)\nops[#ops+1] = v -- We'll put the version of the document at the end.\nreturn ops", 2, getVersionKey(cName, docName), getOpLogKey(cName, docName), from, to, function(err, result) {
      var ops;
      if (err) {
        return callback(err);
      }
      if (result === null) {
        return callback(null, []);
      }
      ops = processRedisOps(to, result);
      return callback(null, ops);
    });
  };
  redisSetExpire = function(cName, docName, v, callback) {
    return redis["eval"]("local versionKey, opLogKey = unpack(KEYS)\nlocal v = unpack(ARGV)\n\nv = tonumber(v)\n\n-- Check the version matches.\nlocal realv = tonumber(redis.call('get', versionKey))\n\nif v == realv - 1 then\n  redis.call('expire', versionKey, 60*60*24) -- 1 day\n  redis.call('expire', opLogKey, 60*60*24) -- 1 day\n  redis.call('ltrim', opLogKey, -100, -1) -- Only 100 ops, counted from the end.\n   \n  --redis.call('del', versionKey)\n  --redis.call('del', opLogKey)\n  --redis.call('del', opLogKey)\n\n  -- Doing this directly for now. I don't know the performance impact, but its cleaner.\n  --redis.call('PUBLISH', publishChannel, opData)\nend", 2, getVersionKey(cName, docName), getOpLogKey(cName, docName), v, callback);
  };
  oplogGetOps = function(cName, docName, from, to, callback) {
    return oplog.getOps(cName, docName, from, to, function(err, ops) {
      var op, _i, _len;
      if (err) {
        return callback(err);
      }
      if (ops.length && ops[0].v !== from) {
        throw new Error('Oplog is returning incorrect ops');
      }
      for (_i = 0, _len = ops.length; _i < _len; _i++) {
        op = ops[_i];
        op.v = from++;
      }
      return callback(null, ops);
    });
  };
  getOps = function(cName, docName, from, to, callback) {
    return redisGetOps(cName, docName, from, to, function(err, ops) {
      if (err) {
        return callback(err);
      }
      if (ops.length) {
        if (ops[0].v === from) {
          return callback(null, ops);
        } else {
          return oplogGetOps(cName, docName, from, ops[0].v, function(err, firstOps) {
            if (err) {
              return callback(err);
            }
            return callback(null, firstOps.concat(ops));
          });
        }
      } else {
        return oplogGetOps(cName, docName, from, to, callback);
      }
    });
  };
  writeOpToLog = function(cName, docName, opData, callback) {
    var entry;
    entry = logEntryForData(opData);
    entry.v = opData.v;
    return oplog.getVersion(cName, docName, function(err, version) {
      var _this = this;
      if (err) {
        return callback(err);
      }
      if (version < opData.v) {
        console.log('populating oplog', version, opData.v);
        return redisGetOps(cName, docName, version, opData.v, function(err, results) {
          var f;
          if (err) {
            return callback(err);
          }
          results.push(entry);
          return (f = function() {
            if (results.length === 0) {
              return callback();
            }
            return oplog.writeOp(cName, docName, results.shift(), function(err) {
              if (err) {
                return callback(err);
              }
              return process.nextTick(f);
            });
          })();
        });
      } else if (version === opData.v) {
        return oplog.writeOp(cName, docName, entry, function(err) {
          return callback(err);
        });
      }
    });
  };
  return client = {
    snapshotDb: snapshotDb,
    oplog: oplog,
    getOps: function(cName, docName, from, to, callback) {
      var _ref;
      if (typeof to === 'function') {
        _ref = [null, to], to = _ref[0], callback = _ref[1];
      }
      if (to >= 0) {
        if ((to != null) && from > to) {
          return callback(null, []);
        }
      }
      if (from == null) {
        return callback('Invalid from field in getOps');
      }
      return getOps(cName, docName, from, to, callback);
    },
    publish: function(channel, data) {
      return redis.publish(prefixChannel(channel), (data ? JSON.stringify(data) : void 0));
    },
    submit: function(cName, docName, opData, options, callback) {
      var err, retry, transformedOps, _ref,
        _this = this;
      if (typeof options === 'function') {
        _ref = [{}, options], options = _ref[0], callback = _ref[1];
      }
      if (options == null) {
        options = {};
      }
      err = ot.checkOpData(opData);
      if (err) {
        return typeof callback === "function" ? callback(err) : void 0;
      }
      ot.normalize(opData);
      transformedOps = [];
      return (retry = function() {
        return _this.fetch(cName, docName, function(err, snapshot) {
          var trySubmit;
          if (err) {
            return typeof callback === "function" ? callback(err) : void 0;
          }
          if (snapshot.v < opData.v) {
            return typeof callback === "function" ? callback('Invalid version') : void 0;
          }
          if (opData.v == null) {
            opData.v = snapshot.v;
          }
          trySubmit = function() {
            return atomicSubmit(cName, docName, opData, function(err, result) {
              if (err) {
                return typeof callback === "function" ? callback(err) : void 0;
              }
              if (result === 'Transform needed') {
                return getOps(cName, docName, opData.v, null, function(err, ops) {
                  var old, _i, _len;
                  if (err) {
                    return typeof callback === "function" ? callback(err) : void 0;
                  }
                  if (ops.length === 0) {
                    return typeof callback === "function" ? callback('Intermediate operations missing - cannot apply op') : void 0;
                  }
                  for (_i = 0, _len = ops.length; _i < _len; _i++) {
                    old = ops[_i];
                    transformedOps.push(old);
                    err = ot.transform(snapshot.type, opData, old);
                    if (err) {
                      return typeof callback === "function" ? callback(err) : void 0;
                    }
                  }
                  return retry();
                });
              }
              if (typeof result === 'string') {
                return typeof callback === "function" ? callback(result) : void 0;
              }
              return writeOpToLog(cName, docName, opData, function(err) {
                if (err) {
                  return typeof callback === "function" ? callback(err) : void 0;
                }
                return snapshotDb.writeSnapshot(cName, docName, snapshot, function(err) {
                  var db, name;
                  if (err) {
                    return typeof callback === "function" ? callback(err) : void 0;
                  }
                  for (name in extraDbs) {
                    db = extraDbs[name];
                    if (typeof db.submit === "function") {
                      db.submit(cName, docName, opData, options, snapshot, _this, function(err) {
                        if (err) {
                          return console.warn("Error updating db " + name + " " + cName + "." + docName + " with new snapshot data: ", err);
                        }
                      });
                    }
                  }
                  opData.docName = docName;
                  redis.publish(prefixChannel(cName), JSON.stringify(opData));
                  redisSetExpire(cName, docName, opData.v, function(err) {
                    if (err) {
                      return console.error(err);
                    }
                  });
                  return typeof callback === "function" ? callback(null, opData.v, transformedOps, snapshot) : void 0;
                });
              });
            });
          };
          if (snapshot.v === opData.v) {
            err = ot.apply(snapshot, opData);
            if (err) {
              if (typeof err !== 'string' && !isError(err)) {
                console.warn('INVALID VALIDATION FN!!!!');
                console.warn('Your validation function must return null/undefined, a string or an error object.');
                console.warn('Instead we got', err);
              }
              return typeof callback === "function" ? callback(err) : void 0;
            }
          }
          return trySubmit();
        });
      })();
    },
    _subscribeChannels: function(channels, callback) {
      var channel, channelList, i, onMessage, open, stream, _i, _len;
      stream = new Readable({
        objectMode: true
      });
      stream._read = function() {};
      open = true;
      stream._id = nextStreamId++;
      streams[stream._id] = stream;
      stream.destroy = function() {
        var channel, i, _i, _len;
        if (!open) {
          return;
        }
        stream.push(null);
        open = false;
        delete streams[stream._id];
        if (Array.isArray(channels)) {
          for (i = _i = 0, _len = channels.length; _i < _len; i = ++_i) {
            channel = channels[i];
            if (--subscribeCounts[channel] > 0) {
              continue;
            }
            redisObserver.unsubscribe(channel);
            delete subscribeCounts[channel];
          }
        } else {
          if (!(--subscribeCounts[channels] > 0)) {
            redisObserver.unsubscribe(channels);
            delete subscribeCounts[channels];
          }
        }
        redisObserver.removeListener('message', onMessage);
        stream.emit('close');
        return stream.emit('end');
      };
      if (Array.isArray(channels)) {
        for (i = _i = 0, _len = channels.length; _i < _len; i = ++_i) {
          channel = channels[i];
          channel = channels[i] = prefixChannel(channel);
          subscribeCounts[channel] = (subscribeCounts[channel] || 0) + 1;
        }
        onMessage = function(msgChannel, msg) {
          var data;
          if (!open || channels.indexOf(msgChannel) === -1) {
            return;
          }
          data = JSON.parse(msg);
          data.channel = msgChannel.slice(msgChannel.indexOf(' ') + 1);
          return stream.push(data);
        };
        channelList = channels;
      } else {
        channels = prefixChannel(channels);
        subscribeCounts[channels] = (subscribeCounts[channels] || 0) + 1;
        onMessage = function(msgChannel, msg) {
          var data;
          if (!open || msgChannel !== channels) {
            return;
          }
          data = JSON.parse(msg);
          return stream.push(data);
        };
        channelList = [channels];
      }
      redisObserver.on('message', onMessage);
      return redisObserver.subscribe.apply(redisObserver, __slice.call(channelList).concat([function(err) {
        if (err) {
          stream.destroy();
          return callback(err);
        }
        return callback(null, stream);
      }]));
    },
    subscribe: function(cName, docName, v, callback) {
      var opChannel,
        _this = this;
      opChannel = getDocOpChannel(cName, docName);
      return this._subscribeChannels(opChannel, function(err, stream) {
        if (err) {
          callback(err);
        }
        return _this.getOps(cName, docName, v, function(err, data) {
          var d, queue, _i, _j, _len, _len1, _results;
          if (err) {
            stream.destroy();
            return callback(err);
          }
          queue = ((function() {
            var _results;
            _results = [];
            while (d = stream.read()) {
              _results.push(d);
            }
            return _results;
          })());
          callback(null, stream);
          for (_i = 0, _len = data.length; _i < _len; _i++) {
            d = data[_i];
            assert(d.v === v);
            v++;
            stream.push(d);
          }
          _results = [];
          for (_j = 0, _len1 = queue.length; _j < _len1; _j++) {
            d = queue[_j];
            if (!(d.v >= v)) {
              continue;
            }
            assert(d.v === v);
            v++;
            _results.push(stream.push(d));
          }
          return _results;
        });
      });
    },
    fetch: function(cName, docName, callback) {
      var _this = this;
      return snapshotDb.getSnapshot(cName, docName, function(err, snapshot) {
        if (err) {
          return typeof callback === "function" ? callback(err) : void 0;
        }
        if (snapshot == null) {
          snapshot = {
            v: 0
          };
        }
        if (snapshot.v == null) {
          return callback('Invalid snapshot data');
        }
        return _this.getOps(cName, docName, snapshot.v, function(err, results) {
          var opData, _i, _len;
          if (err) {
            return typeof callback === "function" ? callback(err) : void 0;
          }
          for (_i = 0, _len = results.length; _i < _len; _i++) {
            opData = results[_i];
            err = ot.apply(snapshot, opData);
          }
          return callback(err, snapshot);
        });
      });
    },
    bulkFetchCached: function(cName, docNames, callback) {
      var abort, docName, i, pending, results, _fn, _i, _len,
        _this = this;
      if (snapshotDb.getBulkSnapshots) {
        return snapshotDb.getBulkSnapshots(cName, docNames, function(err, results) {
          var docName, list, map, r, _i, _len;
          if (err) {
            return callback(err);
          }
          map = {};
          for (_i = 0, _len = results.length; _i < _len; _i++) {
            r = results[_i];
            map[r.docName] = r;
          }
          list = (function() {
            var _j, _len1, _results;
            _results = [];
            for (_j = 0, _len1 = docNames.length; _j < _len1; _j++) {
              docName = docNames[_j];
              _results.push(map[docName] || {
                v: 0
              });
            }
            return _results;
          })();
          return callback(null, list);
        });
      } else {
        results = new Array(docNames.length);
        pending = docNames.length + 1;
        abort = false;
        _fn = function(i) {
          return _this.fetch(cName, docName, function(err, data) {
            if (abort) {
              return;
            }
            if (err) {
              abort = true;
              return callback(err);
            }
            results[i] = data;
            pending--;
            if (pending === 0) {
              return callback(results);
            }
          });
        };
        for (i = _i = 0, _len = docNames.length; _i < _len; i = ++_i) {
          docName = docNames[i];
          _fn(i);
        }
        pending--;
        if (pending === 0) {
          return callback(results);
        }
      }
    },
    fetchAndSubscribe: function(cName, docName, callback) {
      var _this = this;
      return this.fetch(cName, docName, function(err, data) {
        if (err) {
          return callback(err);
        }
        return _this.subscribe(cName, docName, data.v, function(err, stream) {
          return callback(err, data, stream);
        });
      });
    },
    queryFetch: function(cName, query, opts, callback) {
      var db, _ref,
        _this = this;
      if (typeof opts === 'function') {
        _ref = [{}, opts], opts = _ref[0], callback = _ref[1];
      }
      if (opts.backend) {
        if (!extraDbs.hasOwnProperty(opts.backend)) {
          return callback('Backend not found');
        }
        db = extraDbs[opts.backend];
      } else {
        db = snapshotDb;
      }
      return db.query(this, cName, query, function(err, resultset) {
        if (err) {
          return callback(err);
        } else if (Array.isArray(resultset)) {
          return callback(null, resultset);
        } else {
          return callback(null, resultset.results, resultset.extra);
        }
      });
    },
    query: function(index, query, opts, callback) {
      var channels, db, delay, poll, _ref,
        _this = this;
      if (typeof opts === 'function') {
        _ref = [{}, opts], opts = _ref[0], callback = _ref[1];
      }
      if (opts.backend) {
        if (!extraDbs.hasOwnProperty(opts.backend)) {
          return callback('Backend not found');
        }
        db = extraDbs[opts.backend];
      } else if (snapshotDb.query) {
        db = snapshotDb;
      } else {
        return callback('Backend not specified and database does not support queries');
      }
      poll = !db.queryDoc ? true : opts.poll === void 0 && db.queryNeedsPollMode ? db.queryNeedsPollMode(index, query) : opts.poll;
      delay = typeof opts.pollDelay === 'number' ? opts.pollDelay : 2000;
      channels = db.subscribedChannels ? db.subscribedChannels(index, query, opts) : [index];
      return this._subscribeChannels(channels, function(err, stream) {
        if (err) {
          return callback(err);
        }
        return db.query(_this, index, query, function(err, resultset) {
          var d, docIdx, emitter, extra, f, i, results, runQuery, _i, _len;
          if (err) {
            stream.destroy();
            return callback(err);
          }
          emitter = new EventEmitter;
          emitter.destroy = function() {
            return stream.destroy();
          };
          if (!Array.isArray(resultset)) {
            emitter.extra = extra = resultset.extra;
            results = resultset.results;
          } else {
            results = resultset;
          }
          emitter.data = results;
          docIdx = {};
          for (i = _i = 0, _len = results.length; _i < _len; i = ++_i) {
            d = results[i];
            d.c || (d.c = index);
            docIdx["" + d.c + "." + d.docName] = i;
          }
          if (poll) {
            runQuery = rateLimit(delay, function() {
              return db.query(client, index, query, function(err, newResultset) {
                var data, diff, newResults, r, _j, _k, _len1, _len2;
                if (err) {
                  return emitter.emit('error', new Error(err));
                }
                if (!Array.isArray(newResultset)) {
                  if (newResultset.extra) {
                    if (!deepEquals(extra, newResultset.extra)) {
                      emitter.emit('extra', newResultset.extra);
                      emitter.extra = extra = newResultset.extra;
                    }
                  }
                  newResults = newResultset.results;
                } else {
                  newResults = newResultset;
                }
                for (_j = 0, _len1 = newResults.length; _j < _len1; _j++) {
                  r = newResults[_j];
                  r.c || (r.c = index);
                }
                diff = arraydiff(results, newResults, function(a, b) {
                  if (!(a && b)) {
                    return false;
                  }
                  return a.docName === b.docName && a.c === b.c;
                });
                if (diff.length) {
                  emitter.data = results = newResults;
                  for (_k = 0, _len2 = diff.length; _k < _len2; _k++) {
                    data = diff[_k];
                    data.type = data.type;
                  }
                  return emitter.emit('diff', diff);
                }
              });
            });
          }
          (f = function() {
            var _results;
            _results = [];
            while (d = stream.read()) {
              _results.push((function(d) {
                var cachedData, modifies;
                d.c = d.channel;
                cachedData = results[docIdx["" + d.c + "." + d.docName]];
                if (cachedData && cachedData.v > d.v) {
                  return;
                }
                modifies = void 0;
                if (opts.shouldPoll && !opts.shouldPoll(d.c, d.docName, d, index, query)) {
                  return;
                }
                if (modifies === void 0) {
                  if (poll) {
                    return runQuery();
                  } else {
                    return db.queryDoc(client, index, d.c, d.docName, query, function(err, result) {
                      var idx, name, r, _results1;
                      if (err) {
                        return emitter.emit('error', new Error(err));
                      }
                      if (result && !cachedData) {
                        result.c = d.c;
                        results.push(result);
                        emitter.emit('diff', [
                          {
                            type: 'insert',
                            index: results.length - 1,
                            values: [result]
                          }
                        ]);
                        return docIdx["" + result.c + "." + result.docName] = results.length - 1;
                      } else if (!result && cachedData) {
                        name = "" + d.c + "." + d.docName;
                        idx = docIdx[name];
                        delete docIdx[name];
                        emitter.emit('diff', [
                          {
                            type: 'remove',
                            index: idx,
                            howMany: 1
                          }
                        ]);
                        results.splice(idx, 1);
                        _results1 = [];
                        while (idx < results.length) {
                          r = results[idx++];
                          name = "" + r.c + "." + r.docName;
                          _results1.push(docIdx[name]--);
                        }
                        return _results1;
                      }
                    });
                  }
                }
              })(d));
            }
            return _results;
          })();
          stream.on('readable', f);
          return callback(null, emitter);
        });
      });
    },
    collection: function(cName) {
      return {
        submit: function(docName, opData, options, callback) {
          return client.submit(cName, docName, opData, options, callback);
        },
        subscribe: function(docName, v, callback) {
          return client.subscribe(cName, docName, v, callback);
        },
        getOps: function(docName, from, to, callback) {
          return client.getOps(cName, docName, from, to, callback);
        },
        fetch: function(docName, callback) {
          return client.fetch(cName, docName, callback);
        },
        fetchAndObserve: function(docName, callback) {
          return client.fetchAndObserve(cName, docName, callback);
        },
        queryFetch: function(query, opts, callback) {
          return client.queryFetch(cName, query, opts, callback);
        },
        query: function(query, opts, callback) {
          return client.query(cName, query, opts, callback);
        }
      };
    },
    destroy: function() {
      var id, s, _results;
      redis.quit();
      redisObserver.quit();
      _results = [];
      for (id in streams) {
        s = streams[id];
        _results.push(s.destroy());
      }
      return _results;
    }
  };
};

/*
//@ sourceMappingURL=index.map
*/
