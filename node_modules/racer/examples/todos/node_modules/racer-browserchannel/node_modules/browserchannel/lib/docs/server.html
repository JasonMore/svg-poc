<!DOCTYPE html>

<html>
<head>
  <title>A BrowserChannel server.</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
    <ul class="sections">
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap for-h1">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              <h1>A BrowserChannel server.</h1>
<ul>
<li>Its still pretty young, so there&#39;s probably bugs lurking around and the API
will still change quickly.</li>
<li>Its missing integration tests</li>
</ul>
<p>It works in all the browsers I&#39;ve tried.</p>
<p>I&#39;ve written this using the literate programming style to try it out. So, thats why
there&#39;s a million comments everywhere.</p>
<p>The server is implemented as connect middleware. Its intended to be used like this:</p>
<pre><code>server = connect(
  browserChannel (client) -&gt; client.send &#39;hi&#39;
)</code></pre>
<h2>Dependancies, helper methods and constant data</h2>
<p><code>parse</code> helps us decode URLs in requests</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>{parse} = require <span class="string">'url'</span></pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p><code>querystring</code> will help decode the URL-encoded forward channel data</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>querystring = require <span class="string">'querystring'</span></pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p><code>fs</code> is used to read &amp; serve the client library</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>fs = require <span class="string">'fs'</span></pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>Client sessions are <code>EventEmitters</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>{EventEmitter} = require <span class="string">'events'</span></pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>Client session Ids are generated using <code>node-hat</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>hat = require(<span class="string">'hat'</span>).rack(<span class="number">40</span>, <span class="number">36</span>)</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p><code>randomInt(n)</code> generates and returns a random int smaller than n (0 &lt;= k &lt; n)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="title">randomInt</span></span> = (n) -&gt; Math.floor(Math.random() * n)</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p><code>randomArrayElement(array)</code> Selects and returns a random element from <em>array</em></p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="title">randomArrayElement</span></span> = (array) -&gt; array[randomInt(array.length)]</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>For testing we&#39;ll override <code>setInterval</code>, etc with special testing stub versions (so
we don&#39;t have to actually wait for actual <em>time</em>. To do that, we need local variable
versions (I don&#39;t want to edit the global versions). ... and they&#39;ll just point to the
normal versions anyway.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>{setInterval, clearInterval, setTimeout, clearTimeout, Date} = global</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>The module is configurable</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>defaultOptions =</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>An optional array of host prefixes. Each browserchannel client will randomly pick
from the list of host prefixes when it connects. This reduces the impact of per-host
connection limits.</p>
<p>All host prefixes should point to the same server. Ie, if your server&#39;s hostname
is <em>example.com</em> and your hostPrefixes contains [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;],
a.example.com, b.example.com and c.example.com should all point to the same host
as example.com.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  hostPrefixes: <span class="literal">null</span></pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>You can specify the base URL which browserchannel connects to. Change this if you want
to scope browserchannel in part of your app, or if you want /channel to mean something
else, or whatever.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  base: <span class="string">'/channel'</span></pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>We&#39;ll send keepalives every so often to make sure the http connection isn&#39;t closed by
eagar clients. The standard timeout is 30 seconds, so we&#39;ll default to sending them
every 20 seconds or so.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  keepAliveInterval: <span class="number">20</span> * <span class="number">1000</span></pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>After awhile (30 seconds or so) of not having a backchannel connected, we&#39;ll evict the
session completely. This will happen whenever a user closes their browser.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  sessionTimeoutInterval: <span class="number">30</span> * <span class="number">1000</span></pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>By default, browsers don&#39;t allow access via javascript to foreign sites. You can use the
cors: option to set the Access-Control-Allow-Origin header in responses, which tells browsers
whether or not to allow cross domain requests to be sent.</p>
<p>See <a href="https://developer.mozilla.org/en/http_access_control">https://developer.mozilla.org/en/http_access_control</a> for more information.</p>
<p>Setting cors:&#39;*&#39; will enable javascript from any domain to access your application. BE CAREFUL!
If your application uses cookies to manage user sessions, javascript on a foreign site could
make requests as if it were acting on behalf of one of your users.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  cors: <span class="literal">null</span></pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>A user can override all the headers if they want by setting the headers option to an object.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  headers: <span class="literal">null</span></pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>All server responses set some standard HTTP headers.
To be honest, I don&#39;t know how many of these are necessary. I just copied
them from google.</p>
<p>The nocache headers in particular seem unnecessary since each client
request includes a randomized <code>zx=junk</code> query parameter.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>standardHeaders =
  <span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span>
  <span class="string">'Cache-Control'</span>: <span class="string">'no-cache, no-store, max-age=0, must-revalidate'</span>
  <span class="string">'Pragma'</span>: <span class="string">'no-cache'</span>
  <span class="string">'Expires'</span>: <span class="string">'Fri, 01 Jan 1990 00:00:00 GMT'</span>
  <span class="string">'X-Content-Type-Options'</span>: <span class="string">'nosniff'</span></pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>Gmail also sends this, though I&#39;m not really sure what it does...
 &#39;X-Xss-Protection&#39;: &#39;1; mode=block&#39;</p>
<p>The one exception to that is requests destined for iframes. They need to
have content-type: text/html set for IE to process the juicy JS inside.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>ieHeaders = {}
ieHeaders[k] = v <span class="keyword">for</span> k, v <span class="keyword">of</span> standardHeaders
ieHeaders[<span class="string">'Content-Type'</span>] = <span class="string">'text/html'</span></pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>Google&#39;s browserchannel server adds some junk after the first message data is sent. I
assume this stops some whole-page buffering in IE. I assume the data used is noise so it
doesn&#39;t compress.</p>
<p>I don&#39;t really know why google does this. I&#39;m assuming there&#39;s a good reason to it though.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>ieJunk = <span class="string">"7cca69475363026330a0d99468e88d23ce95e222591126443015f5f462d9a177186c8701fb45a6ffe
e0daf1a178fc0f58cd309308fba7e6f011ac38c9cdd4580760f1d4560a84d5ca0355ecbbed2ab715a3350fe0c47
9050640bd0e77acec90c58c4d3dd0f5cf8d4510e68c8b12e087bd88cad349aafd2ab16b07b0b1b8276091217a44
a9fe92fedacffff48092ee693af\n"</span></pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p>If the user is using IE, instead of using XHR backchannel loaded using
a forever iframe. When data is sent, it is wrapped in <script></script> tags
which call functions in the browserchannel library.</p>
<p>This method wraps the normal <code>.writeHead()</code>, <code>.write()</code> and <code>.end()</code> methods by
special versions which produce output based on the request&#39;s type.</p>
<p>This <strong>is not used</strong> for:</p>
<ul>
<li>The first channel test</li>
<li>The first <em>bind</em> connection a client makes. The server sends arrays there, but the
connection is a POST and it returns immediately. So that request happens using XHR/Trident
like regular forward channel requests.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="title">messagingMethods</span></span> = (options, query, res) -&gt;
  type = query.TYPE
  <span class="keyword">if</span> type == <span class="string">'html'</span>
    junkSent = <span class="literal">false</span>

    methods =
      writeHead: -&gt;
        res.writeHead <span class="number">200</span>, <span class="string">'OK'</span>, ieHeaders
        res.write <span class="string">'&lt;html&gt;&lt;body&gt;'</span>

        domain = query.DOMAIN</pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p>If the iframe is making the request using a secondary domain, I think we need
to set the <code>domain</code> to the original domain so that we can call the response methods.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">if</span> domain <span class="keyword">and</span> domain != <span class="string">''</span></pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <p>Make sure the domain doesn&#39;t contain anything by naughty by <code>JSON.stringify()</code>-ing
it before passing it to the client. There are XSS vulnerabilities otherwise.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          res.write <span class="string">"&lt;script&gt;try{document.domain=<span class="subst">#{JSON.stringify domain}</span>;}catch(e){}&lt;/script&gt;\n"</span>
    
      write: (data) -&gt;</pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <p>The data is passed to <code>m()</code>, which is bound to <em>onTridentRpcMessage_</em> in the client.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        res.write <span class="string">"&lt;script&gt;try {parent.m(<span class="subst">#{JSON.stringify data}</span>)} catch(e) {}&lt;/script&gt;\n"</span>
        <span class="keyword">unless</span> junkSent
          res.write ieJunk
          junkSent = <span class="literal">true</span>

      end: -&gt;</pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p>Once the data has been received, the client needs to call <code>d()</code>, which is bound to
<em>onTridentDone_</em> with success=<em>true</em>.
The weird spacing of this is copied from browserchannel. Its really not necessary.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        res.end <span class="string">"&lt;script&gt;try  {parent.d(); }catch (e){}&lt;/script&gt;\n"</span></pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <p>This is a helper method for signalling an error in the request back to the client.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      writeError: (statusCode, message) -&gt;</pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <p>The HTML (iframe) handler has no way to discover that the embedded script tag
didn&#39;t complete successfully. To signal errors, we return <strong>200 OK</strong> and call an
exposed rpcClose() method on the page.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        methods.writeHead()
        res.end <span class="string">"&lt;script&gt;try {parent.rpcClose(<span class="subst">#{JSON.stringify message}</span>)} catch(e){}&lt;/script&gt;\n"</span></pre></div></div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <p>For some reason, sending data during the second test (111112) works slightly differently for
XHR, but its identical for html encoding. We&#39;ll use a writeRaw() method in that case, which
is copied in the case of html.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    methods.writeRaw = methods.write

    methods

  <span class="keyword">else</span></pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <p>For normal XHR requests, we send data normally.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    writeHead: -&gt; res.writeHead <span class="number">200</span>, <span class="string">'OK'</span>, options.headers
    write: (data) -&gt; res.write <span class="string">"<span class="subst">#{data.length}</span>\n<span class="subst">#{data}</span>"</span>
    writeRaw: (data) -&gt; res.write data
    end: -&gt; res.end()
    writeError: (statusCode, message) -&gt;
      res.writeHead statusCode, options.headers
      res.end message</pre></div></div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <p>For telling the client its done bad.</p>
<p>It turns out google&#39;s server isn&#39;t particularly fussy about signalling errors using the proper
html RPC stuff, so this is useful for html connections too.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="title">sendError</span></span> = (res, statusCode, message) -&gt;
  res.writeHead statusCode, message
  res.end <span class="string">"&lt;html&gt;&lt;body&gt;&lt;h1&gt;<span class="subst">#{message}</span>&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;"</span>
  <span class="keyword">return</span></pre></div></div>
            
        </li>
        
        
        <li id="section-29">
            <div class="annotation">
              
              <div class="pilwrap for-h2">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <h2>Parsing client maps from the forward channel</h2>
<p>The client sends data in a series of url-encoded maps. The data is encoded like this:</p>
<pre><code>count=2&amp;ofs=0&amp;req0_x=3&amp;req0_y=10&amp;req1_abc=def</code></pre>
<p>First, we need to buffer up the request response and query string decode it.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="title">bufferPostData</span></span> = (req, callback) -&gt;
  data = []
  req.<span class="literal">on</span> <span class="string">'data'</span>, (chunk) -&gt;
    data.push chunk.toString <span class="string">'utf8'</span>
  req.<span class="literal">on</span> <span class="string">'end'</span>, -&gt;
    data = data.join <span class="string">''</span>
    callback data</pre></div></div>
            
        </li>
        
        
        <li id="section-30">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <p>Next, we&#39;ll need to decode the incoming client data into an array of objects.</p>
<p>The data could be in two different forms:</p>
<ul>
<li>Classical browserchannel format, which is a bunch of string-&gt;string url-encoded maps</li>
<li>A JSON object</li>
</ul>
<p>We can tell what format the data is in by inspecting the content-type header</p>
<h2>URL Encoded data</h2>
<p>Essentially, url encoded the data looks like this:</p>
<pre><code>{ count: &#39;2&#39;,
  ofs: &#39;0&#39;,
  req0_x: &#39;3&#39;,
  req0_y: &#39;10&#39;,
  req1_abc: &#39;def&#39;
}</code></pre>
<p>... and we will return an object in the form of <code>[{x:&#39;3&#39;, y:&#39;10&#39;}, {abc: &#39;def&#39;}, ...]</code></p>
<h2>JSON Encoded data</h2>
<p>JSON encoded the data looks like:</p>
<pre><code>{ ofs: 0
, data: [null, {...}, 1000.4, &#39;hi&#39;, ...]
}</code></pre>
<p>or <code>null</code> if there&#39;s no data.</p>
<p>This function returns null if there&#39;s no data or {ofs, json:[...]} or {ofs, maps:[...]}</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="title">transformData</span></span> = (req, data) -&gt;
  <span class="keyword">if</span> req.headers[<span class="string">'content-type'</span>] == <span class="string">'application/json'</span></pre></div></div>
            
        </li>
        
        
        <li id="section-31">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <p>We&#39;ll restructure it slightly to mark the data as JSON rather than maps.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    {ofs, data} = data
    {ofs, json:data}
  <span class="keyword">else</span>
    count = parseInt data.count
    <span class="keyword">return</span> <span class="literal">null</span> <span class="keyword">if</span> count <span class="keyword">is</span> <span class="number">0</span></pre></div></div>
            
        </li>
        
        
        <li id="section-32">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>
              <p>ofs will be missing if count is zero</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    ofs = parseInt data.ofs
    <span class="keyword">throw</span> <span class="keyword">new</span> Error <span class="string">'invalid map data'</span> <span class="keyword">if</span> isNaN count <span class="keyword">or</span> isNaN ofs
    <span class="keyword">throw</span> <span class="keyword">new</span> Error <span class="string">'Invalid maps'</span> <span class="keyword">unless</span> count == <span class="number">0</span> <span class="keyword">or</span> (count &gt; <span class="number">0</span> <span class="keyword">and</span> data.ofs?)

    maps = <span class="keyword">new</span> Array count</pre></div></div>
            
        </li>
        
        
        <li id="section-33">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-33">&#182;</a>
              </div>
              <p>Scan through all the keys in the data. Every key of the form:
<code>req123_xxx</code> will be used to populate its map.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    regex = <span class="regexp">/^req(\d+)_(.+)$/</span>
    <span class="keyword">for</span> key, val <span class="keyword">of</span> data
      match = regex.exec key
      <span class="keyword">if</span> match
        id = match[<span class="number">1</span>]
        mapKey = match[<span class="number">2</span>]
        map = (maps[id] ||= {})</pre></div></div>
            
        </li>
        
        
        <li id="section-34">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-34">&#182;</a>
              </div>
              <p>The client uses <code>mapX_type=_badmap</code> to signify an error encoding a map.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">continue</span> <span class="keyword">if</span> id == <span class="string">'type'</span> <span class="keyword">and</span> mapKey == <span class="string">'_badmap'</span>
        map[mapKey] = val

    {ofs, maps}</pre></div></div>
            
        </li>
        
        
        <li id="section-35">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-35">&#182;</a>
              </div>
              <p>Decode data string body and get an object back
Either a query string format or JSON depending on content type</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="title">decodeData</span></span> = (req, data) -&gt;
  <span class="keyword">if</span> req.headers[<span class="string">'content-type'</span>] == <span class="string">'application/json'</span>
    JSON.parse data
  <span class="keyword">else</span></pre></div></div>
            
        </li>
        
        
        <li id="section-36">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-36">&#182;</a>
              </div>
              <p>Maps. Ugh.</p>
<p>By default, querystring.parse only parses out the first 1000 keys from the data.
maxKeys:0 removes this restriction.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    querystring.parse data, <span class="string">'&amp;'</span>, <span class="string">'='</span>, maxKeys:<span class="number">0</span></pre></div></div>
            
        </li>
        
        
        <li id="section-37">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-37">&#182;</a>
              </div>
              <p>This is a helper method to order the handling of messages / requests / whatever.</p>
<p>Use it like this:
inOrder = order 0</p>
<p>inOrder 1, -&gt; console.log &#39;second&#39;
inOrder 0, -&gt; console.log &#39;first&#39;</p>
<p>Start is the ID of the first element we expect to receive. If we get data for earlier
elements, we&#39;ll play them anyway if playOld is truthy.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="function"><span class="title">order</span></span> = (start, playOld) -&gt;</pre></div></div>
            
        </li>
        
        
        <li id="section-38">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-38">&#182;</a>
              </div>
              <p>Base is the ID of the (missing) element at the start of the queue</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  base = start</pre></div></div>
            
        </li>
        
        
        <li id="section-39">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-39">&#182;</a>
              </div>
              <p>The queue will start with about 10 elements. Elements of the queue are undefined
if we don&#39;t have data for that queue element.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  queue = <span class="keyword">new</span> Array <span class="number">10</span>

  (seq, callback) -&gt;</pre></div></div>
            
        </li>
        
        
        <li id="section-40">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-40">&#182;</a>
              </div>
              <p>Its important that all the cells of the array are truthy if we have data. We&#39;ll use an
empty function instead of null.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    callback <span class="function"><span class="title">or</span></span>= -&gt;</pre></div></div>
            
        </li>
        
        
        <li id="section-41">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-41">&#182;</a>
              </div>
              <p>Ignore old messages, or play them back immediately if playOld=true</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">if</span> seq &lt; base
      callback() <span class="keyword">if</span> playOld
    <span class="keyword">else</span>
      queue[seq - base] = callback

      <span class="keyword">while</span> queue[<span class="number">0</span>]
        callback = queue.shift()
        base++
        callback()</pre></div></div>
            
        </li>
        
        
        <li id="section-42">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-42">&#182;</a>
              </div>
              <p>We need access to the client&#39;s sourcecode. I&#39;m going to get it using a synchronous file call
(it&#39;ll be fast anyway, and only happen once).</p>
<p>I&#39;m also going to set an etag on the client data so the browser client will be cached. I&#39;m kind of
uncomfortable about adding complexity here because its not like this code hasn&#39;t been written
before, but.. I think a lot of people will use this API.</p>
<p>I should probably look into hosting the client code as a javascript module using that client-side
npm thing.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>clientFile = <span class="string">"<span class="subst">#{__dirname}</span>/../dist/bcsocket.js"</span>
clientStats = fs.statSync clientFile
<span class="keyword">try</span>
  clientCode = fs.readFileSync clientFile, <span class="string">'utf8'</span>
<span class="keyword">catch</span> e
  console.error <span class="string">'Could not load the client javascript. Run `cake client` to generate it.'</span>
  <span class="keyword">throw</span> e</pre></div></div>
            
        </li>
        
        
        <li id="section-43">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-43">&#182;</a>
              </div>
              <p>This is mostly to help development, but if the client is recompiled, I&#39;ll pull in a new version.
This isn&#39;t tested by the unit tests - but its not a big deal.</p>
<p>The <code>readFileSync</code> call here will stop the whole server while the client is reloaded.
This will only happen during development so its not a big deal.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="keyword">if</span> process.platform <span class="keyword">is</span> <span class="string">"win32"</span></pre></div></div>
            
        </li>
        
        
        <li id="section-44">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-44">&#182;</a>
              </div>
              <p>Windows doesn&#39;t support watchFile. See:
<a href="https://github.com/josephg/node-browserchannel/pull/6">https://github.com/josephg/node-browserchannel/pull/6</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  fs.watch clientFile, persistent: <span class="literal">false</span>, (event, filename) -&gt;
    <span class="keyword">if</span> event <span class="keyword">is</span> <span class="string">"change"</span>
      console.log <span class="string">"Reloading client JS"</span>
      clientCode = fs.readFileSync clientFile, <span class="string">'utf8'</span>
      clientStats = curr
<span class="keyword">else</span>
  fs.watchFile clientFile, persistent: <span class="literal">false</span>, (curr, prev) -&gt;
    <span class="keyword">if</span> curr.mtime.getTime() <span class="keyword">isnt</span> prev.mtime.getTime()
      console.log <span class="string">"Reloading client JS"</span>
      clientCode = fs.readFileSync clientFile, <span class="string">'utf8'</span>
      clientStats = curr</pre></div></div>
            
        </li>
        
        
        <li id="section-45">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-45">&#182;</a>
              </div>
              <hr>

            </div>
            
        </li>
        
        
        <li id="section-46">
            <div class="annotation">
              
              <div class="pilwrap for-h1">
                <a class="pilcrow" href="#section-46">&#182;</a>
              </div>
              <h1>The server middleware</h1>
<p>The server module returns a function, which you can call with your configuration
options. It returns your configured connect middleware, which is actually another function.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>module.exports = <span class="function"><span class="title">browserChannel</span></span> = (options, onConnect) -&gt;
  <span class="keyword">if</span> <span class="keyword">typeof</span> onConnect == <span class="string">'undefined'</span>
    onConnect = options
    options = {}

  options ||= {}
  options[option] ?= value <span class="keyword">for</span> option, value <span class="keyword">of</span> defaultOptions

  options.headers = {} <span class="keyword">unless</span> options.headers
  options.headers[h] ||= v <span class="keyword">for</span> h, v <span class="keyword">of</span> standardHeaders
  options.headers[<span class="string">'Access-Control-Allow-Origin'</span>] = options.cors <span class="keyword">if</span> options.cors</pre></div></div>
            
        </li>
        
        
        <li id="section-47">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-47">&#182;</a>
              </div>
              <p>Strip off a trailing slash in base.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  base = options.base
  base = base[... base.length - <span class="number">1</span>] <span class="keyword">if</span> base.match <span class="regexp">/\/$/</span></pre></div></div>
            
        </li>
        
        
        <li id="section-48">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-48">&#182;</a>
              </div>
              <p>Add a leading slash back on base</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  base = <span class="string">"/<span class="subst">#{base}</span>"</span> <span class="keyword">unless</span> base.match <span class="regexp">/^\//</span></pre></div></div>
            
        </li>
        
        
        <li id="section-49">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-49">&#182;</a>
              </div>
              <p>map from sessionId -&gt; session</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  sessions = {}</pre></div></div>
            
        </li>
        
        
        <li id="section-50">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-50">&#182;</a>
              </div>
              <p>Host prefixes provide a way to skirt around connection limits. They&#39;re only
really important for old browsers.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="function"><span class="title">getHostPrefix</span></span> = -&gt;
    <span class="keyword">if</span> options.hostPrefixes
      randomArrayElement options.hostPrefixes
    <span class="keyword">else</span>
      <span class="literal">null</span></pre></div></div>
            
        </li>
        
        
        <li id="section-51">
            <div class="annotation">
              
              <div class="pilwrap for-h1">
                <a class="pilcrow" href="#section-51">&#182;</a>
              </div>
              <h1>Create a new client session.</h1>
<p>This method will start a new client session.</p>
<p>Session ids are generated by <a href="https://github.com/substack/node-hat">node-hat</a>. They are guaranteed to be unique.</p>
<p>This method is synchronous, because a database will never be involved in browserchannel
session management. Browserchannel sessions only last as long as the user&#39;s browser
is open. If there&#39;s any connection turbulence, the client will reconnect and get
a new session id.</p>
<p>Sometimes a client will specify an old session ID and old array ID. In this case, the client
is reconnecting and we should evict the named session (if it exists).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="function"><span class="title">createSession</span></span> = (address, query, headers) -&gt;
    {RID:initialRid, CVER:appVersion, OSID:oldSessionId, OAID:oldArrayId} = query

    <span class="keyword">if</span> oldSessionId? <span class="keyword">and</span> (oldSession = sessions[oldSessionId])
      oldSession._acknowledgeArrays oldArrayId
      oldSession.close <span class="string">'Reconnected'</span></pre></div></div>
            
        </li>
        
        
        <li id="section-52">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-52">&#182;</a>
              </div>
              <p>Create a new session. Sessions extend node&#39;s <a href="http://nodejs.org/docs/v0.4.12/api/events.html">EventEmitter</a> so they have access to
goodies like <code>session.on(event, handler)</code>, <code>session.emit(&#39;paarty&#39;)</code>, etc.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    session = <span class="keyword">new</span> EventEmitter</pre></div></div>
            
        </li>
        
        
        <li id="section-53">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-53">&#182;</a>
              </div>
              <p>The session&#39;s unique ID for this connection</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    session.id = hat()</pre></div></div>
            
        </li>
        
        
        <li id="section-54">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-54">&#182;</a>
              </div>
              <p>The client stores its IP address and headers from when it first opened the session. The
handler can use this information for authentication or something.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    session.address = address
    session.headers = headers</pre></div></div>
            
        </li>
        
        
        <li id="section-55">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-55">&#182;</a>
              </div>
              <p>The session is a little state machine. It has the following states:</p>
<ul>
<li><p><strong>init</strong>: The session has been created and its sessionId hasn&#39;t been sent yet.
The session moves to the <strong>ok</strong> state when the first data chunk is sent to the
client.</p>
</li>
<li><p><strong>ok</strong>: The session is sitting pretty and ready to send and receive data.
The session will spend most of its time in this state.</p>
</li>
<li><p><strong>closed</strong>: The session has been removed from the session list. It can no longer
be used for any reason.</p>
<p>It is invalid to send arrays to a session while it is closed. Unless you&#39;re
Bruce Willis...</p>
</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>    session.state = <span class="string">'init'</span></pre></div></div>
            
        </li>
        
        
        <li id="section-56">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-56">&#182;</a>
              </div>
              <p>The state is modified through this method. It emits events when the state changes.
(yay)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="function"><span class="title">changeState</span></span> = (newState) -&gt;
      oldState = session.state
      session.state = newState
      session.emit <span class="string">'state changed'</span>, session.state, oldState</pre></div></div>
            
        </li>
        
        
        <li id="section-57">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-57">&#182;</a>
              </div>
              <p>The server sends messages to the client via a hanging GET request. Of course,
the client has to be the one to open that request.</p>
<p>This is a handle to null, or {res, methods, chunk}</p>
<ul>
<li><strong>res</strong> is the http response object</li>
<li><strong>methods</strong> is a map of send(), etc methods for communicating properly with the backchannel -
this will be different if the request comes from IE or not.</li>
<li><strong>chunk</strong> specifies whether or not we&#39;re going to keep the connection open across multiple
messages. If there&#39;s a buffering proxy in the way of the connection, we can&#39;t respond a bit at
a time, so we close the backchannel after each data chunk. The client decides this during
testing and passes a CI= parameter to the server when the backchannel connection is established.</li>
<li><strong>bytesSent</strong> specifies how many bytes of data have been sent through the backchannel. We periodically
close the backchannel and let the client reopen it, so things like the chrome web inspector stay
usable.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>    backChannel = <span class="literal">null</span></pre></div></div>
            
        </li>
        
        
        <li id="section-58">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-58">&#182;</a>
              </div>
              <p>The server sends data to the client by sending <em>arrays</em>. It seems a bit silly that
client-&gt;server messages are maps and server-&gt;client messages are arrays, but there it is.</p>
<p>Each entry in this array is of the form [id, data].</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    outgoingArrays = []</pre></div></div>
            
        </li>
        
        
        <li id="section-59">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-59">&#182;</a>
              </div>
              <p><code>lastArrayId</code> is the array ID of the last queued array</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    lastArrayId = -<span class="number">1</span></pre></div></div>
            
        </li>
        
        
        <li id="section-60">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-60">&#182;</a>
              </div>
              <p>Every request from the client has an <em>AID</em> parameter which tells the server the ID
of the last request the client has received. We won&#39;t remove arrays from the outgoingArrays
list until the client has confirmed its received them.</p>
<p>In <code>lastSentArrayId</code> we store the ID of the last array which we actually sent.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    lastSentArrayId = -<span class="number">1</span></pre></div></div>
            
        </li>
        
        
        <li id="section-61">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-61">&#182;</a>
              </div>
              <p>I would like this method to be private or something, but it needs to be accessed from
the HTTP request code below. The _ at the start will hopefully make people think twice
before using it.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    session.<span class="function"><span class="title">_setBackChannel</span></span> = (res, query) -&gt;
      clearBackChannel()

      backChannel =
        res: res
        methods: messagingMethods options, query, res
        chunk: query.CI == <span class="string">'0'</span>
        bytesSent: <span class="number">0</span>
        listener: -&gt;
          backChannel.listener = <span class="literal">null</span>
          clearBackChannel res</pre></div></div>
            
        </li>
        
        
        <li id="section-62">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-62">&#182;</a>
              </div>
              <p>When the TCP connection underlying the backchannel request is closed, we&#39;ll stop using the
backchannel and start the session timeout clock. The listener is kept so the event handler 
removed once the backchannel is closed.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      res.connection.once <span class="string">'close'</span>, backChannel.listener</pre></div></div>
            
        </li>
        
        
        <li id="section-63">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-63">&#182;</a>
              </div>
              <p>We&#39;ll start the heartbeat interval and clear out the session timeout.
The session timeout will be started again if the backchannel connection closes for
any reason.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      refreshHeartbeat()
      clearTimeout sessionTimeout</pre></div></div>
            
        </li>
        
        
        <li id="section-64">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-64">&#182;</a>
              </div>
              <p>When a new backchannel is created, its possible that the old backchannel is dead.
In this case, its possible that previously sent arrays haven&#39;t been received.
By resetting lastSentArrayId, we&#39;re effectively rolling back the status of sent arrays
to only those arrays which have been acknowledged.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      lastSentArrayId = outgoingArrays[<span class="number">0</span>].id - <span class="number">1</span> <span class="keyword">if</span> outgoingArrays.length &gt; <span class="number">0</span></pre></div></div>
            
        </li>
        
        
        <li id="section-65">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-65">&#182;</a>
              </div>
              <p>Send any arrays we&#39;ve buffered now that we have a backchannel</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="property">@flush</span>()</pre></div></div>
            
        </li>
        
        
        <li id="section-66">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-66">&#182;</a>
              </div>
              <p>If we haven&#39;t sent anything for 15 seconds, we&#39;ll send a little <code>[&#39;noop&#39;]</code> to the
client so it knows we haven&#39;t forgotten it. (And to make sure the backchannel
connection doesn&#39;t time out.)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    heartbeat = <span class="literal">null</span></pre></div></div>
            
        </li>
        
        
        <li id="section-67">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-67">&#182;</a>
              </div>
              <p>This method removes the back channel and any state associated with it. It&#39;ll get called
when the backchannel closes naturally, is replaced or when the connection closes.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="function"><span class="title">clearBackChannel</span></span> = (res) -&gt;</pre></div></div>
            
        </li>
        
        
        <li id="section-68">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-68">&#182;</a>
              </div>
              <p>clearBackChannel doesn&#39;t do anything if we call it repeatedly.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">return</span> <span class="keyword">unless</span> backChannel</pre></div></div>
            
        </li>
        
        
        <li id="section-69">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-69">&#182;</a>
              </div>
              <p>Its important that we only delete the backchannel if the closed connection is actually
the backchannel we&#39;re currently using.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">return</span> <span class="keyword">if</span> res? <span class="keyword">and</span> res != backChannel.res

      <span class="keyword">if</span> backChannel.listener</pre></div></div>
            
        </li>
        
        
        <li id="section-70">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-70">&#182;</a>
              </div>
              <p>The backchannel listener has been attached to the &#39;close&#39; event of the underlying TCP
stream. We don&#39;t care about that anymore</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        backChannel.res.connection.removeListener <span class="string">'close'</span>, backChannel.listener
        backChannel.listener = <span class="literal">null</span></pre></div></div>
            
        </li>
        
        
        <li id="section-71">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-71">&#182;</a>
              </div>
              <p>Conveniently, clearTimeout has no effect if the argument is null.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      clearTimeout heartbeat

      backChannel.methods.end()
      backChannel = <span class="literal">null</span></pre></div></div>
            
        </li>
        
        
        <li id="section-72">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-72">&#182;</a>
              </div>
              <p>Whenever we don&#39;t have a backchannel, we run the session timeout timer.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      refreshSessionTimeout()</pre></div></div>
            
        </li>
        
        
        <li id="section-73">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-73">&#182;</a>
              </div>
              <p>This method sets / resets the heartbeat timeout to the full 15 seconds.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="function"><span class="title">refreshHeartbeat</span></span> = -&gt;
      clearTimeout heartbeat

      heartbeat = setInterval (-&gt; session.send [<span class="string">'noop'</span>]), options.keepAliveInterval</pre></div></div>
            
        </li>
        
        
        <li id="section-74">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-74">&#182;</a>
              </div>
              <p>The session will close if there&#39;s been no backchannel for awhile.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    sessionTimeout = <span class="literal">null</span>

    <span class="function"><span class="title">refreshSessionTimeout</span></span> = -&gt;
      clearTimeout sessionTimeout
      sessionTimeout = setTimeout (-&gt; session.close <span class="string">'Timed out'</span>), options.sessionTimeoutInterval</pre></div></div>
            
        </li>
        
        
        <li id="section-75">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-75">&#182;</a>
              </div>
              <p>Since the session doesn&#39;t start with a backchannel, we&#39;ll kick off the timeout timer as soon as its
created.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    refreshSessionTimeout()</pre></div></div>
            
        </li>
        
        
        <li id="section-76">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-76">&#182;</a>
              </div>
              <p>The arrays get removed once they&#39;ve been acknowledged</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    session.<span class="function"><span class="title">_acknowledgeArrays</span></span> = (id) -&gt;
      id = parseInt id <span class="keyword">if</span> <span class="keyword">typeof</span> id <span class="keyword">is</span> <span class="string">'string'</span>

      <span class="keyword">while</span> outgoingArrays.length &gt; <span class="number">0</span> <span class="keyword">and</span> outgoingArrays[<span class="number">0</span>].id &lt;= id
        {confirmcallback} = outgoingArrays.shift()</pre></div></div>
            
        </li>
        
        
        <li id="section-77">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-77">&#182;</a>
              </div>
              <p>I&#39;ve got no idea what to do if we get an exception thrown here. The session will end up
in an inconsistant state...</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        confirmcallback?()

      <span class="keyword">return</span></pre></div></div>
            
        </li>
        
        
        <li id="section-78">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-78">&#182;</a>
              </div>
              <p>Queue an array to be sent. The optional callbacks notifies a caller when the array has been
sent, and then received by the client.</p>
<p>If the session is already closed, we&#39;ll call the confirmation callback immediately with the
error.</p>
<p>queueArray returns the ID of the queued data chunk.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="function"><span class="title">queueArray</span></span> = (data, sendcallback, confirmcallback) -&gt;
      <span class="keyword">return</span> confirmcallback? <span class="keyword">new</span> Error <span class="string">'closed'</span> <span class="keyword">if</span> session.state <span class="keyword">is</span> <span class="string">'closed'</span>

      id = ++lastArrayId
      outgoingArrays.push {id, data, sendcallback, confirmcallback}

      lastArrayId</pre></div></div>
            
        </li>
        
        
        <li id="section-79">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-79">&#182;</a>
              </div>
              <p>The session has just been created. The first thing it needs to tell the client
is its session id and host prefix and stuff.</p>
<p>It would be pretty easy to add a callback here setting the client status to &#39;ok&#39; or
something, but its not really necessary. The client has already connected once the first
POST /bind has been received.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    queueArray [<span class="string">'c'</span>, session.id, getHostPrefix(), <span class="number">8</span>]</pre></div></div>
            
        </li>
        
        
        <li id="section-80">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-80">&#182;</a>
              </div>
              <p>Send the array data through the backchannel. This takes an optional callback which
will be called with no arguments when the client acknowledges the array, or called with an
error object if the client disconnects before the array is sent.</p>
<p>queueArray can also take a callback argument which is called when the session sends the message
in the first place. I&#39;m not sure if I should expose this through send - I can&#39;t tell if its
useful beyond the server code.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    session.<span class="function"><span class="title">send</span></span> = (arr, callback) -&gt;
      id = queueArray arr, <span class="literal">null</span>, callback
      <span class="property">@flush</span>()
      id</pre></div></div>
            
        </li>
        
        
        <li id="section-81">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-81">&#182;</a>
              </div>
              <h3>Maps</h3>
<p>The client sends maps to the server using POST requests. Its possible for the requests
to come in out of order, so sometimes we need to buffer up incoming maps and reorder them
before emitting them to the user.</p>
<p>Each map has an ID (which starts at 0 when the session is first created). </p>
<p>We&#39;ll emit received data to the user immediately if they&#39;re in order, but if they&#39;re out of order
we&#39;ll use the little order helper above to order them. The order helper is instructed to not
emit any old messages twice.</p>
<p>There&#39;s a potential DOS attack here whereby a client could just spam the server with
out-of-order maps until it runs out of memory. We should dump a session if there are
too many entries in this dictionary.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    mapBuffer = order <span class="number">0</span>, <span class="literal">false</span></pre></div></div>
            
        </li>
        
        
        <li id="section-82">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-82">&#182;</a>
              </div>
              <p>This method is called whenever we get maps from the client. Offset is the ID of the first
map. The data could either be maps or JSON data. If its maps, data contains {maps} and if its
JSON data, maps contains {JSON}.</p>
<p>Browserchannel has 2 different mechanisms for consistantly ordering messages in the forward channel:</p>
<ul>
<li><p>Each forward channel request contains a request ID (RID=X), which start at a random value
(set with the first session create packet). These increment by 1 with each request.</p>
<p>If a request fails, it might be retried with the same RID as the previous message, and with extra
maps tacked on the end. We need to handle the maps in this case.</p>
</li>
<li><p>Each map has an ID, counting from 0. ofs= in the POST data tells the server the ID of the first
map in a request.</p>
</li>
</ul>
<p>As far as I can tell, the RID stuff can mostly be ignored. The one place it is important is in
handling disconnect messages. The session should only be disconnected by a disconnect message when
the preceeding messages have been received.</p>
<p>All requests are handled in order too, though if not for disconnecting I don&#39;t think it would matter.
Because of the funky retry-has-extra-maps logic, we&#39;ll allow processing requests twice.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    ridBuffer = order initialRid, <span class="literal">true</span>

    session.<span class="function"><span class="title">_receivedData</span></span> = (rid, data) -&gt;
      ridBuffer rid, -&gt;
        <span class="keyword">return</span> <span class="keyword">if</span> data <span class="keyword">is</span> <span class="literal">null</span>
        <span class="keyword">throw</span> <span class="keyword">new</span> Error <span class="string">'Invalid data'</span> <span class="keyword">unless</span> data.maps? <span class="keyword">or</span> data.json?

        ridBuffer rid
        id = data.ofs</pre></div></div>
            
        </li>
        
        
        <li id="section-83">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-83">&#182;</a>
              </div>
              <p>First, classic browserchannel maps.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">if</span> data.maps</pre></div></div>
            
        </li>
        
        
        <li id="section-84">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-84">&#182;</a>
              </div>
              <p>If an exception is thrown during this loop, I&#39;m not really sure what the behaviour should be.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="keyword">for</span> map <span class="keyword">in</span> data.maps</pre></div></div>
            
        </li>
        
        
        <li id="section-85">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-85">&#182;</a>
              </div>
              <p>The funky do expression here is used to pass the map into the closure.
Another way to do it is to index into the data.maps array inside the function, but then I&#39;d
need to pass the index to the closure anyway.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            mapBuffer id++, <span class="keyword">do</span> (map) -&gt; -&gt;
              <span class="keyword">return</span> <span class="keyword">if</span> session.state <span class="keyword">is</span> <span class="string">'closed'</span>

              session.emit <span class="string">'map'</span>, map</pre></div></div>
            
        </li>
        
        
        <li id="section-86">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-86">&#182;</a>
              </div>
              <p>If you specify the key as JSON, the server will try to decode JSON data from the map and emit
&#39;message&#39;. This is a much nicer way to message the server.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>              <span class="keyword">if</span> map.JSON?
                <span class="keyword">try</span>
                  message = JSON.parse map.JSON
                <span class="keyword">catch</span> e
                  session.close <span class="string">'Invalid JSON'</span>
                  <span class="keyword">return</span>
                session.emit <span class="string">'message'</span>, message
        <span class="keyword">else</span></pre></div></div>
            
        </li>
        
        
        <li id="section-87">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-87">&#182;</a>
              </div>
              <p>We have data.json. We&#39;ll just emit it directly.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="keyword">for</span> message <span class="keyword">in</span> data.json
            mapBuffer id++, <span class="keyword">do</span> (map) -&gt; -&gt;
              <span class="keyword">return</span> <span class="keyword">if</span> session.state <span class="keyword">is</span> <span class="string">'closed'</span>
              session.emit <span class="string">'message'</span>, message

    session.<span class="function"><span class="title">_disconnectAt</span></span> = (rid) -&gt;
      ridBuffer rid, -&gt; session.close <span class="string">'Disconnected'</span></pre></div></div>
            
        </li>
        
        
        <li id="section-88">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-88">&#182;</a>
              </div>
              <p>When we receive forwardchannel data, we reply with a special little 3-variable array to tell the
client if it should reopen the backchannel.</p>
<p>This method returns what the forward channel should reply with.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    session.<span class="function"><span class="title">_backChannelStatus</span></span> = -&gt;</pre></div></div>
            
        </li>
        
        
        <li id="section-89">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-89">&#182;</a>
              </div>
              <p>Find the arrays have been sent over the wire but haven&#39;t been acknowledged yet</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      numUnsentArrays = lastArrayId - lastSentArrayId
      unacknowledgedArrays = outgoingArrays[... outgoingArrays.length - numUnsentArrays]
      outstandingBytes = <span class="keyword">if</span> unacknowledgedArrays.length == <span class="number">0</span>
        <span class="number">0</span>
      <span class="keyword">else</span></pre></div></div>
            
        </li>
        
        
        <li id="section-90">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-90">&#182;</a>
              </div>
              <p>We don&#39;t care about the length of the array IDs or callback functions.
I&#39;m actually not sure what data the client expects here - the value is just used in a rough
heuristic to determine if the backchannel should be reopened.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        data = (a.data <span class="keyword">for</span> a <span class="keyword">in</span> unacknowledgedArrays)
        JSON.stringify(data).length

      [
        (<span class="keyword">if</span> backChannel <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span>)
        lastSentArrayId
        outstandingBytes
      ]</pre></div></div>
            
        </li>
        
        
        <li id="section-91">
            <div class="annotation">
              
              <div class="pilwrap for-h2">
                <a class="pilcrow" href="#section-91">&#182;</a>
              </div>
              <h2>Encoding server arrays for the back channel</h2>
<p>The server sends data to the client in <strong>chunks</strong>. Each chunk is a <em>JSON</em> array prefixed
by its length in bytes.</p>
<p>The array looks like this:</p>
<pre><code>[
  [100, [&#39;message&#39;, &#39;one&#39;]],
  [101, [&#39;message&#39;, &#39;two&#39;]],
  [102, [&#39;message&#39;, &#39;three&#39;]]
]</code></pre>
<p>Each individial message is prefixed by its <em>array id</em>, which is a counter starting at 0
when the session is first created and incremented with each array.</p>
<p>This will actually send the arrays to the backchannel on the next tick if the backchannel
is alive.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    session.<span class="function"><span class="title">flush</span></span> = -&gt;
      process.nextTick -&gt;
        <span class="keyword">if</span> backChannel
          numUnsentArrays = lastArrayId - lastSentArrayId
          <span class="keyword">if</span> numUnsentArrays &gt; <span class="number">0</span>
            arrays = outgoingArrays[outgoingArrays.length - numUnsentArrays ...]</pre></div></div>
            
        </li>
        
        
        <li id="section-92">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-92">&#182;</a>
              </div>
              <p>I&#39;ve abused outgoingArrays to also contain some callbacks. We only send [id, data] to
the client.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            data = ([id, data] <span class="keyword">for</span> {id, data} <span class="keyword">in</span> arrays)
            bytes = JSON.stringify(data) + <span class="string">"\n"</span></pre></div></div>
            
        </li>
        
        
        <li id="section-93">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-93">&#182;</a>
              </div>
              <p>Stand back, pro hax! Ideally there is a general solution for escaping these characters
when converting to JSON.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            bytes = bytes.replace(<span class="regexp">/\u2028/g</span>, <span class="string">"\\u2028"</span>)
            bytes = bytes.replace(<span class="regexp">/\u2029/g</span>, <span class="string">"\\u2029"</span>)</pre></div></div>
            
        </li>
        
        
        <li id="section-94">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-94">&#182;</a>
              </div>
              <p><strong>Away!</strong></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            backChannel.methods.write bytes
            backChannel.bytesSent += bytes.length

            lastSentArrayId = lastArrayId</pre></div></div>
            
        </li>
        
        
        <li id="section-95">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-95">&#182;</a>
              </div>
              <p>Fire any send callbacks on the messages. These callbacks should only be called once.
Again, not sure what to do if there are exceptions here.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="keyword">for</span> a <span class="keyword">in</span> arrays
              <span class="keyword">if</span> a.sendcallback?
                a.sendcallback?()
                <span class="keyword">delete</span> a.sendcallback</pre></div></div>
            
        </li>
        
        
        <li id="section-96">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-96">&#182;</a>
              </div>
              <p>The send callback could have cleared the backchannel by calling close.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="keyword">if</span> backChannel <span class="keyword">and</span> (!backChannel.chunk <span class="keyword">or</span> backChannel.bytesSent &gt; <span class="number">10</span> * <span class="number">1024</span>)
              clearBackChannel()</pre></div></div>
            
        </li>
        
        
        <li id="section-97">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-97">&#182;</a>
              </div>
              <p>The first backchannel is the client&#39;s initial connection. Once we&#39;ve sent the first
data chunk to the client, we&#39;ve officially opened the connection.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          changeState <span class="string">'ok'</span> <span class="keyword">if</span> session.state == <span class="string">'init'</span></pre></div></div>
            
        </li>
        
        
        <li id="section-98">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-98">&#182;</a>
              </div>
              <p>The client&#39;s reported application version, or null. This is sent when the
connection is first requested, so you can use it to make your application die / stay
compatible with people who don&#39;t close their browsers.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    session.appVersion = appVersion <span class="keyword">or</span> <span class="literal">null</span></pre></div></div>
            
        </li>
        
        
        <li id="section-99">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-99">&#182;</a>
              </div>
              <p>Signal to a client that it should stop trying to connect. This has no other effect
on the server session.</p>
<p><code>stop</code> takes a callback which will be called once the message has been <em>sent</em> by the server.
Typically, you should call it like this:</p>
<pre><code>session.stop -&gt;
  session.close()</code></pre>
<p>I considered making this automatically close the connection after you&#39;ve called it, or after
you&#39;ve sent the stop message or something, but if I did that it wouldn&#39;t be obvious that you
can still receive messages after stop() has been called. (Because you can!). That would never
come up when you&#39;re testing locally, but it <em>would</em> come up in production. This is more obvious.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    session.<span class="function"><span class="title">stop</span></span> = (callback) -&gt;
      <span class="keyword">return</span> <span class="keyword">if</span> <span class="property">@state</span> <span class="keyword">is</span> <span class="string">'closed'</span>
      queueArray [<span class="string">'stop'</span>], callback, <span class="literal">null</span>
      <span class="property">@flush</span>()</pre></div></div>
            
        </li>
        
        
        <li id="section-100">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-100">&#182;</a>
              </div>
              <p>This closes a session and makes the server forget about it.</p>
<p>The client might try and reconnect if you only call <code>close()</code>. It&#39;ll get a new session if it does so.</p>
<p>close takes an optional message argument, which is passed to the send event handlers.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    session.<span class="function"><span class="title">close</span></span> = (message) -&gt;</pre></div></div>
            
        </li>
        
        
        <li id="section-101">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-101">&#182;</a>
              </div>
              <p>You can&#39;t double-close.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">return</span> <span class="keyword">if</span> <span class="property">@state</span> == <span class="string">'closed'</span>

      changeState <span class="string">'closed'</span>
      <span class="property">@emit</span> <span class="string">'close'</span>, message

      clearBackChannel()
      clearTimeout sessionTimeout

      <span class="keyword">for</span> {confirmcallback} <span class="keyword">in</span> outgoingArrays
        confirmcallback? <span class="keyword">new</span> Error(message || <span class="string">'closed'</span>)
      
      <span class="keyword">delete</span> sessions[<span class="property">@id</span>]</pre></div></div>
            
        </li>
        
        
        <li id="section-102">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-102">&#182;</a>
              </div>
              <p>console.log &quot;closed #{@id}&quot;</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    sessions[session.id] = session

    session</pre></div></div>
            
        </li>
        
        
        <li id="section-103">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-103">&#182;</a>
              </div>
              <p>This is the returned middleware. Connect middleware is a function which
takes in an http request, an http response and a next method.</p>
<p>The middleware can do one of two things:</p>
<ul>
<li>Handle the request, sending data back to the server via the response</li>
<li>Call <code>next()</code>, which allows the next middleware in the stack a chance to
handle the request.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="function"><span class="title">middleware</span></span> = (req, res, next) -&gt;
    {query, pathname} = parse req.url, <span class="literal">true</span></pre></div></div>
            
        </li>
        
        
        <li id="section-104">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-104">&#182;</a>
              </div>
              <p>console.warn req.method, req.url</p>

            </div>
            
        </li>
        
        
        <li id="section-105">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-105">&#182;</a>
              </div>
              <p>If base is /foo, we don&#39;t match /foobar. (Currently no unit tests for this)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">return</span> next() <span class="keyword">if</span> pathname.substring(<span class="number">0</span>, base.length + <span class="number">1</span>) != <span class="string">"<span class="subst">#{base}</span>/"</span>

    {writeHead, write, writeRaw, end, writeError} = messagingMethods options, query, res</pre></div></div>
            
        </li>
        
        
        <li id="section-106">
            <div class="annotation">
              
              <div class="pilwrap for-h1">
                <a class="pilcrow" href="#section-106">&#182;</a>
              </div>
              <h1>Serving the client</h1>
<p>The browserchannel server hosts a usable web client library at /CHANNEL/bcsocket.js.
This library wraps the google closure library client implementation.</p>
<p>If I have time, I would like to write my own version of the client to add a few features
(websockets, message acknowledgement callbacks) and do some manual optimisations for speed.
However, the current version works ok.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">if</span> pathname <span class="keyword">is</span> <span class="string">"<span class="subst">#{base}</span>/bcsocket.js"</span>
      etag = <span class="string">"\"<span class="subst">#{clientStats.size}</span>-<span class="subst">#{clientStats.mtime.getTime()}</span>\""</span>
      res.writeHead <span class="number">200</span>, <span class="string">'OK'</span>,
        <span class="string">'Content-Type'</span>: <span class="string">'application/javascript'</span>,
        <span class="string">'ETag'</span>: etag,
        <span class="string">'Content-Length'</span>: clientCode.length</pre></div></div>
            
        </li>
        
        
        <li id="section-107">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-107">&#182;</a>
              </div>
              <p>This code is manually tested because it looks like its impossible to send HEAD requests
using nodejs&#39;s HTTP library at time of writing (0.4.12). (Yeah, I know, rite?)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">if</span> req.method <span class="keyword">is</span> <span class="string">'HEAD'</span>
        res.end()
      <span class="keyword">else</span>
        res.end clientCode</pre></div></div>
            
        </li>
        
        
        <li id="section-108">
            <div class="annotation">
              
              <div class="pilwrap for-h1">
                <a class="pilcrow" href="#section-108">&#182;</a>
              </div>
              <h1>Connection testing</h1>
<p>Before the browserchannel client connects, it tests the connection to make
sure its working, and to look for buffering proxies.</p>
<p>The server-side code for connection testing is completely stateless.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">else</span> <span class="keyword">if</span> pathname <span class="keyword">is</span> <span class="string">"<span class="subst">#{base}</span>/test"</span></pre></div></div>
            
        </li>
        
        
        <li id="section-109">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-109">&#182;</a>
              </div>
              <p>This server only supports browserchannel protocol version <strong>8</strong>.
I have no idea if 400 is the right error here.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">return</span> sendError res, <span class="number">400</span>, <span class="string">'Version 8 required'</span> <span class="keyword">unless</span> query.VER <span class="keyword">is</span> <span class="string">'8'</span></pre></div></div>
            
        </li>
        
        
        <li id="section-110">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-110">&#182;</a>
              </div>
              <h3>Phase 1: Server info</h3>
<p>The client is requests host prefixes. The server responds with an array of
[&#39;hostprefix&#39; or null, &#39;blockedprefix&#39; or null].</p>
<blockquote>
<p>Actually, I think you might be able to return [] if neither hostPrefix nor blockedPrefix
is defined. (Thats what google wave seems to do)</p>
</blockquote>
<ul>
<li><p><strong>hostprefix</strong> is subdomain prepended onto the hostname of each request.
This gets around browser connection limits. Using this requires a bank of
configured DNS entries and SSL certificates if you&#39;re using HTTPS.</p>
</li>
<li><p><strong>blockedprefix</strong> provides network admins a way to blacklist browserchannel
requests. It is not supported by node-browserchannel.</p>
</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">if</span> query.MODE == <span class="string">'init'</span> <span class="keyword">and</span> req.method == <span class="string">'GET'</span>
        hostPrefix = getHostPrefix()
        blockedPrefix = <span class="literal">null</span> <span class="comment"># Blocked prefixes aren't supported.</span></pre></div></div>
            
        </li>
        
        
        <li id="section-111">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-111">&#182;</a>
              </div>
              <p>We add an extra special header to tell the client that this server likes
json-encoded forward channel data over form urlencoded channel data.</p>
<p>It might be easier to put these headers in the response body or increment the
version, but that might conflict with future browserchannel versions.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        headers = {}
        headers[k] = v <span class="keyword">for</span> k, v <span class="keyword">of</span> options.headers
        headers[<span class="string">'X-Accept'</span>] = <span class="string">'application/json; application/x-www-form-urlencoded'</span></pre></div></div>
            
        </li>
        
        
        <li id="section-112">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-112">&#182;</a>
              </div>
              <p>This is a straight-up normal HTTP request like the forward channel requests.
We don&#39;t use the funny iframe write methods.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        res.writeHead <span class="number">200</span>, <span class="string">'OK'</span>, headers
        res.end(JSON.stringify [hostPrefix, blockedPrefix])

      <span class="keyword">else</span></pre></div></div>
            
        </li>
        
        
        <li id="section-113">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-113">&#182;</a>
              </div>
              <h3>Phase 2: Buffering proxy detection</h3>
<p>The client is trying to determine if their connection is buffered or unbuffered.
We reply with &#39;11111&#39;, then 2 seconds later &#39;2&#39;.</p>
<p>The client should get the data in 2 chunks - but they won&#39;t if there&#39;s a misbehaving
corporate proxy in the way or something.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        writeHead()
        writeRaw <span class="string">'11111'</span>
        setTimeout (-&gt; writeRaw <span class="string">'2'</span>; end()), <span class="number">2000</span></pre></div></div>
            
        </li>
        
        
        <li id="section-114">
            <div class="annotation">
              
              <div class="pilwrap for-h1">
                <a class="pilcrow" href="#section-114">&#182;</a>
              </div>
              <h1>BrowserChannel connection</h1>
<p>Once a client has finished testing its connection, it connects.</p>
<p>BrowserChannel communicates through two connections:</p>
<ul>
<li>The <strong>forward channel</strong> is used for the client to send data to the server.
It uses a <strong>POST</strong> request for each message.</li>
<li>The <strong>back channel</strong> is used to get data back from the server. This uses a
hanging <strong>GET</strong> request. If chunking is disallowed (ie, if the proxy buffers)
then the back channel is closed after each server message.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="keyword">else</span> <span class="keyword">if</span> pathname == <span class="string">"<span class="subst">#{base}</span>/bind"</span></pre></div></div>
            
        </li>
        
        
        <li id="section-115">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-115">&#182;</a>
              </div>
              <p>I&#39;m copying the behaviour of unknown SIDs below. I don&#39;t know how the client
is supposed to detect this error, but, eh. The other choice is to <code>return writeError ...</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">return</span> sendError res, <span class="number">400</span>, <span class="string">'Version 8 required'</span> <span class="keyword">unless</span> query.VER <span class="keyword">is</span> <span class="string">'8'</span></pre></div></div>
            
        </li>
        
        
        <li id="section-116">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-116">&#182;</a>
              </div>
              <p>All browserchannel connections have an associated client object. A client
is created immediately if the connection is new.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">if</span> query.SID
        session = sessions[query.SID]</pre></div></div>
            
        </li>
        
        
        <li id="section-117">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-117">&#182;</a>
              </div>
              <p>This is a special error code for the client. It tells the client to abandon its
connection request and reconnect.</p>
<p>For some reason, google replies with the same response on HTTP and HTML requests here.
I&#39;ll follow suit, though its a little weird. Maybe I should do the same with all client
errors?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">return</span> sendError res, <span class="number">400</span>, <span class="string">'Unknown SID'</span> <span class="keyword">unless</span> session

      session._acknowledgeArrays query.AID <span class="keyword">if</span> query.AID? <span class="keyword">and</span> session</pre></div></div>
            
        </li>
        
        
        <li id="section-118">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-118">&#182;</a>
              </div>
              <h3>Forward Channel</h3>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="keyword">if</span> req.method == <span class="string">'POST'</span>
        <span class="keyword">if</span> session == <span class="literal">undefined</span></pre></div></div>
            
        </li>
        
        
        <li id="section-119">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-119">&#182;</a>
              </div>
              <p>The session is new! Make them a new session object and let the
application know.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          session = createSession req.connection.remoteAddress, query, req.headers
          onConnect? session

        <span class="function"><span class="title">dataError</span></span> = (e) -&gt;
          console.warn <span class="string">'Error parsing forward channel'</span>, e.stack
          <span class="keyword">return</span> sendError res, <span class="number">400</span>, <span class="string">'Bad data'</span>

        <span class="function"><span class="title">processData</span></span> = (data) -&gt;
          <span class="keyword">try</span>
            data = transformData req, data
            session._receivedData query.RID, data
          <span class="keyword">catch</span> e
            <span class="keyword">return</span> dataError e
          <span class="keyword">if</span> session.state <span class="keyword">is</span> <span class="string">'init'</span></pre></div></div>
            
        </li>
        
        
        <li id="section-120">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-120">&#182;</a>
              </div>
              <p>The initial forward channel request is also used as a backchannel for the server&#39;s
initial data (session id, etc). This connection is a little bit special - it is always
encoded using length-prefixed json encoding and it is closed as soon as the first chunk is
sent.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            res.writeHead <span class="number">200</span>, <span class="string">'OK'</span>, options.headers
            session._setBackChannel res, CI:<span class="number">1</span>, TYPE:<span class="string">'xmlhttp'</span>, RID:<span class="string">'rpc'</span>
            session.flush()
          <span class="keyword">else</span> <span class="keyword">if</span> session.state <span class="keyword">is</span> <span class="string">'closed'</span></pre></div></div>
            
        </li>
        
        
        <li id="section-121">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-121">&#182;</a>
              </div>
              <p>If the onConnect handler called close() immediately, session.state can be already closed at this point.
I&#39;ll assume there was an authentication problem and treat this as a forbidden connection attempt.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            sendError res, <span class="number">403</span>, <span class="string">'Forbidden'</span>
          <span class="keyword">else</span></pre></div></div>
            
        </li>
        
        
        <li id="section-122">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-122">&#182;</a>
              </div>
              <p>On normal forward channels, we reply to the request by telling the session
if our backchannel is still live and telling it how many unconfirmed
arrays we have.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            response = JSON.stringify session._backChannelStatus()
            res.writeHead <span class="number">200</span>, <span class="string">'OK'</span>, options.headers
            res.end <span class="string">"<span class="subst">#{response.length}</span>\n<span class="subst">#{response}</span>"</span>

        <span class="keyword">if</span> req.body
          processData req.body
        <span class="keyword">else</span>
          bufferPostData req, (data) -&gt;
            <span class="keyword">try</span>
              data = decodeData req, data
            <span class="keyword">catch</span> e
              <span class="keyword">return</span> dataError e
            processData data

      <span class="keyword">else</span> <span class="keyword">if</span> req.method <span class="keyword">is</span> <span class="string">'GET'</span></pre></div></div>
            
        </li>
        
        
        <li id="section-123">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-123">&#182;</a>
              </div>
              <h3>Back channel</h3>
<p>GET messages are usually backchannel requests (server-&gt;client). Backchannel messages are handled
by the session object.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">if</span> query.TYPE <span class="keyword">in</span> [<span class="string">'xmlhttp'</span>, <span class="string">'html'</span>]
          <span class="keyword">return</span> sendError res, <span class="number">400</span>, <span class="string">'Invalid SID'</span> <span class="keyword">if</span> <span class="keyword">typeof</span> query.SID != <span class="string">'string'</span> &amp;&amp; query.SID.length &lt; <span class="number">5</span>
          <span class="keyword">return</span> sendError res, <span class="number">400</span>, <span class="string">'Expected RPC'</span> <span class="keyword">unless</span> query.RID <span class="keyword">is</span> <span class="string">'rpc'</span>
          writeHead()
          session._setBackChannel res, query</pre></div></div>
            
        </li>
        
        
        <li id="section-124">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-124">&#182;</a>
              </div>
              <p>The client can manually disconnect by making a GET request with TYPE=&#39;terminate&#39;</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">else</span> <span class="keyword">if</span> query.TYPE <span class="keyword">is</span> <span class="string">'terminate'</span></pre></div></div>
            
        </li>
        
        
        <li id="section-125">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-125">&#182;</a>
              </div>
              <p>We don&#39;t send any data in the response to the disconnect message.</p>
<p>The client implements this using an img= appended to the page.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          session?._disconnectAt query.RID
          res.writeHead <span class="number">200</span>, <span class="string">'OK'</span>, options.headers
          res.end()

      <span class="keyword">else</span>
        res.writeHead <span class="number">405</span>, <span class="string">'Method Not Allowed'</span>, options.headers
        res.end <span class="string">"Method not allowed"</span>

    <span class="keyword">else</span></pre></div></div>
            
        </li>
        
        
        <li id="section-126">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-126">&#182;</a>
              </div>
              <p>We&#39;ll 404 the user instead of letting another handler take care of it.
Users shouldn&#39;t be using the specified URL prefix for anything else.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      res.writeHead <span class="number">404</span>, <span class="string">'Not Found'</span>, options.headers
      res.end <span class="string">"Not found"</span>

  middleware.<span class="function"><span class="title">close</span></span> = -&gt; session.close() <span class="keyword">for</span> id, session <span class="keyword">of</span> sessions</pre></div></div>
            
        </li>
        
        
        <li id="section-127">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-127">&#182;</a>
              </div>
              <p>This is an undocumented, untested treat - if you pass the HTTP server / connect server to
browserchannel through the options object, it can attach a close listener for you automatically.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  options.server?.<span class="literal">on</span> <span class="string">'close'</span>, middleware.close

  middleware</pre></div></div>
            
        </li>
        
        
        <li id="section-128">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-128">&#182;</a>
              </div>
              <p>This will override the timer methods (<code>setInterval</code>, etc) with the testing stub versions,
which are way faster.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>browserChannel.<span class="function"><span class="title">_setTimerMethods</span></span> = (methods) -&gt;
  {setInterval, clearInterval, setTimeout, clearTimeout, Date} = methods</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
